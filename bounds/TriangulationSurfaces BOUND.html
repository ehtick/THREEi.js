<!DOCTYPE html>
<!-- bounds for unlimited surfaces such as cylinders  -->
<head>
	<title> TriangulationSurfacesBOUNDS </title>
	<meta charset="utf-8" />
</head>

<body>
	progress <input type="range" id="range"  min="0" max="10000" value="5000" step="1" style="width: 80%;" >
</body>
<script src="../js/three.min.106.js"></script>
<script src="../js/OrbitControls.js"></script>

<!-- rename the example js
	<script src="implicitSurface example.js"></script>
	
examples:  
	<script src="implicitSurface sphere cylinder.js"></script>
	<script src="implicitSurface cylinder.js"></script> 
	<script src="implicitSurface two cylinder parallel.js"></script>
	<script src="implicitSurface y sin.js"></script>  problems with bounds
	<script src="implicitSurface two cylinder.js"></script> bounds not okay 
	<script src="implicitSurface sphere cone.js"></script> one bound not okay
 -->
 
	<script src="implicitSurface two cylinder sphere.js"></script> 
 
<script>

// @author hofk 

// Algorithmus nach / Algorithm based on
// de: https://www2.mathematik.tu-darmstadt.de/~ehartmann/cdg0/cdg0n.pdf
// en: https://www2.mathematik.tu-darmstadt.de/~ehartmann/cdgen0104.pdf

'use strict'

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 0.01, 1000 );
camera.position.set( 4, 4, 12 );
const renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setClearColor( 0x999999, 1 );
const container = document.createElement( 'div' );
document.body.appendChild( container );
container.appendChild( renderer.domElement ); 
const controls = new THREE.OrbitControls( camera, renderer.domElement );
const axesHelper = new THREE.AxesHelper( 1 );
scene.add( axesHelper );

const progressFactor = 2.5; // for slider

// ..........................................................

const g = new THREE.BufferGeometry( );

triangulationBounds( isf, dx, dy, dz, xs, ys, zs, d, e, fc, pc, b ); // parameters defined in implicitSurface example.js
//triangulationBounds( isf, dx, dy, dz, xs, ys, zs, d, e );
//...........................................................

const material1 = new THREE.MeshBasicMaterial( { side: THREE.DoubleSide, color: 0x000000, wireframe: true, transparent: true, opacity: 0.99 } );
const mesh1 = new THREE.Mesh( g, material1 );
scene.add( mesh1 );
const material2 = new THREE.MeshBasicMaterial( { side: THREE.FrontSide, color: 0x006600, transparent: true, opacity: 0.9 } );
const mesh2 = new THREE.Mesh( g, material2 );
scene.add( mesh2 );

animate( );

// ....................................

function animate( ) {

	g.setDrawRange(  0, range.value * 3 * progressFactor );
	 
	requestAnimationFrame( animate );
	renderer.render( scene, camera );
	controls.update( );
	
}

// ....................................

function triangulationBounds( isf, dx, dy, dz, xs, ys, zs, d, e, fc, pc, b ) {

	/*  parameters:
		g   THREE.BufferGeometry
		isf implicit surface function
		dx  partial derivate to x
		dy  partial derivate to y
		dz  partial derivate to z
		xs  x start point
		ys  y start point
		zs  z start point
		d   rough edge length of triangles
		e   epsilon for iteration Newton
		optional:	
		fc  faces ( max. number of triangles )
		pc  positions ( max. number of points )
		b   bounds,  array [ xMax, xMin, yMax, yMin, zMax, zMin ]
			normally use only one coordinate e.g. [ Infinity, -Infinity, Infinity, -Infinity, 2, -2 ]	
				
	*/
	
	g.fc = fc !== undefined ? fc : 320000;
	g.pc = pc !== undefined ? pc : 160000;
	
	let bd = b !== undefined ? b : [ Infinity, -Infinity, Infinity, -Infinity, Infinity, -Infinity ];

	const squareLength = ( x,y,z ) => (  x*x + y*y + z*z );
	const length = ( x,y,z ) => ( Math.sqrt( x*x + y*y + z*z ) );
	const prevFront = ( i ) => ( i !== 0 ? i - 1 : front.length - 1 );
	const nextFront = ( i ) => ( i !== front.length - 1 ? i + 1 : 0 );
	const determinant = ( xa,ya,za, xb,yb,zb, xc,yc,zc ) => ( xa*yb*zc + ya*zb*xc + za*xb*yc - za*yb*xc - xa*zb*yc - ya*xb*zc );
	
	let m; // index of the current front point
	let n; // number of new points
	let nT; // number of new triangles
	let nIns; // number of new points (after union or split)
	let dAng; // partial angle
	let phi; // angle (new points)
	let len, d1, d2, d12; // lengths
	let iSplit, jSplit; // split front indices  
	let iUnite, jUnite, fUnite; // unite front indices, front number (to unite) 
	
	// points and vectors:
	let xp, yp, zp; // actual point p
	let x1, y1, z1, x2, y2, z2; // previous and next point to p in front
	let xn, yn, zn; // partial derivations on point p, normal, gradient
	let xt1, yt1, zt1, xt2, yt2, zt2; // tangents
	let xs1, ys1, xs2, ys2; // p in tangential system (only x, y required)
	let xc, yc, zc; // actual point as center point for new points
	
	//  preparation
	
	g.indices = new Uint32Array( g.fc * 3 );
	g.positions = new Float32Array( g.pc * 3 );
	g.normals = new Float32Array( g.pc * 3 );
	
	g.setIndex( new THREE.BufferAttribute( g.indices, 1 ) );
	g.addAttribute( 'position', new THREE.BufferAttribute( g.positions, 3 ) );
	g.addAttribute( 'normal', new THREE.BufferAttribute( g.normals, 3 ) );
	
	let posIdx = 0;
	let indIdx = 0;
	let frontPosIdx, unionIdxA, unionIdxB, splitIdx;
	 
	let front = []; // active front // front[ i ]: object { idx: 0, ang: 0, bou: false } // bou:  boundary point
	let partFront = []; // separated part of the active front (to split)
	let insertFront = []; // new front points to insert into active front
	let fronts = []; // all fronts
	let partBounds = []; // bounding box of partFront [ xmin, xmax, ymin, ymax, zmin, zmax ]
	let boundings = []; // fronts bounding boxes
	let noCheck = []; // no distance check (point indices)
	let smallAngles = []; // new angles < 1.5
	
	let unite = false;
	let split = false;
	
	let dd = d * d;
	
	fronts.push( [] );
	boundings.push( [] );
	
	let frontStock = 0; // number of fronts still to be processed
	let activeFrontNo = 0;
	front = fronts[ activeFrontNo ];
	
	let pCount; // count available points in active front
		
	///////////////////// DEBUG triangles /////////////////////////
	//let stp = 0; 
	///////////////////////////////////////////////////////////////
	
	makeFirstTriangle( ); // first triangle creates a front
	
	// ------ triangulation cycle -------------
	
	while ( frontStock > 0 ) {	
		
		if (  !unite && !split ) { // triangulation on the front
				
			smallAngles = [];
		
			for ( let i = 0; i < front.length; i ++ ) {
			
				// is to be recalculated (angle was set to zero, not for boundary point)
				if( front[ i ].ang === 0 && !front[ i ].bou ) calculateFrontAngle( i ); 
					
			}
			
			m = getMinimalAngleIndex( ); // front angle
			makeNewTriangles( m );		
					
			if ( front.length > 9 && smallAngles.length === 0 ) {
			
				checkDistancesToUnite( m );
				checkDistancesToSplit( m );
				
			}
			
			pCount = 0;
			
			for ( let i = 0; i < front.length; i ++ ) {
				
				if ( !front[ i ].bou ) pCount ++; // count available points (means no boundary point)
				
			}			
			
			if ( front.length === 3 || pCount === 0 ) { // close front
				
				if ( front.length === 3 ) makeLastTriangle( );
			
				front = [];			
				fronts[ activeFrontNo ] = [];		
				frontStock -= 1;	
				chooseNextFront( ); // if available
				
			}
			
		} else {
			
			// unite the active front to another front or split the active front
		
			if ( unite ) {

				uniteFront(  m, iUnite, fUnite, jUnite );
				trianglesAtUnionPoints( );
				
				unite = false;
				
			} else if ( split ) {				
				
				splitFront( iSplit, jSplit );
				trianglesAtSplitPoints( );			
				split = false;
				
			}
			
		}
				
		/////////////// DEBUG triangles /////////////////////
		//if ( stp > 500 ) break;
		///////////////////////////////////////////////////////
		
	}
	
	// .....  detail functions .....	
			
	function makeFirstTriangle( ) {
		
		xp = xs;
		yp = ys;
		zp = zs;
		
		iterationNewton( );
		
		// first point
		g.positions[ posIdx     ] = xp;
		g.positions[ posIdx + 1 ] = yp;
		g.positions[ posIdx + 2 ] = zp;
		
		// first normal
		g.normals[ posIdx     ] = xn;
		g.normals[ posIdx + 1 ] = yn;
		g.normals[ posIdx + 2 ] = zn;
		
		front.push( { idx: posIdx / 3, ang: 0, bou: false } ); // first front point, no boundary point
		
		posIdx += 3;
		
		// start point neighbour
		x1 = xs + d / 32;
		y1 = ys + d / 32;
		z1 = zs + d / 32;
		
		calculateTangentsPoint( ); // start point and neighbour
		
		xc = xp;
		yc = yp;
		zc = zp;
		
		phi = 0;
	
		for ( let i = 0; i < 2; i ++ ) {
					
			calculateSurfacePointAndNormal( );
			
			front.push( { idx: posIdx / 3, ang: 0, bou: false } ); 
			
			posIdx += 3;
			
			phi += Math.PI / 3;
			
		}

		g.indices[ indIdx     ] = 0;
		g.indices[ indIdx + 1 ] = 1;	
		g.indices[ indIdx + 2 ] = 2;	
		
		indIdx += 3;
		
		frontStock += 1;
		
	}
					
	function checkDistancesToUnite( m ) { // for new active front points
	
		let idxJ, xChk, yChk, zChk, ddUnite;													 				 
		let ddUniteMin = Infinity;
		unite = false;
		
		for ( let i = 0; i < insertFront.length; i ++ ) {
			
			if ( !front[ m + i ].bou ) {  // not for boundary point
				
				getPoint( m + i );
				
				for ( let f = 0; f < fronts.length; f ++ ) { 
				
					if ( f !== activeFrontNo ) {
						
						xChk = ( xp > boundings[ f ][ 0 ] - d ) && ( xp < boundings[ f ][ 3 ] + d );
						yChk = ( yp > boundings[ f ][ 1 ] - d ) && ( yp < boundings[ f ][ 4 ] + d );
						zChk = ( zp > boundings[ f ][ 2 ] - d ) && ( zp < boundings[ f ][ 5 ] + d );
						
						if (  xChk || yChk || zChk ) {
							
							for ( let j = 0; j < fronts[ f ].length; j ++ ) {
								
								if ( !fronts[ f ][ j ].bou ) { // not for boundary point
	
									idxJ = fronts[ f ][ j ].idx * 3;
									
									// Hint: here (2) is exceptionally point in other front! 						
									x2 = g.positions[ idxJ ]; 
									y2 = g.positions[ idxJ + 1 ];
									z2 = g.positions[ idxJ + 2 ];
									
									ddUnite = squareLength ( x2 - xp, y2 - yp, z2 - zp );
										
									if ( ddUnite < dd && ddUnite < ddUniteMin ) {
			
										ddUniteMin = ddUnite; 
										iUnite = i;
										jUnite = j;
										fUnite = f;
										unite = true;	
																			
									}
									
								}
								
							}
							
						}
						
					}
					
				}		
				
			}
			
		}
		
	}

	function uniteFront( m, i, f, j ) {
		
		let tmp = [];
		
		tmp[ 0 ] = front.slice( 0, m + i + 1 );	
		tmp[ 1 ] = fronts[ f ].slice( j , fronts[ f ].length );
		tmp[ 2 ] = fronts[ f ].slice( 0 , j + 1 );
		tmp[ 3 ] = front.slice( m + i, front.length );
		
		unionIdxA = m + i;
		unionIdxB = m + i + 1 + fronts[ f ].length
		
		front = [];
		
		for ( let t = 0; t < 4; t ++ ) {
			
			for ( let k = 0; k < tmp[ t ].length ; k ++ ) {
				
				front.push( tmp[ t ][ k ] );
				
			}
			
		}
		
		fronts[ f ] = []; // empty united front
		
		frontStock -= 1; // front is eliminated
		
	}
		
	function trianglesAtUnionPoints( ) {
		
		nIns = 0; // count inserted points
		
		calculateFrontAngle( unionIdxA );
		calculateFrontAngle( unionIdxA + 1 );
		
		if ( front[ unionIdxA ].ang < front[ unionIdxA + 1 ].ang ) {
			
			makeNewTriangles( unionIdxA );
			nIns += n - 1;
			calculateFrontAngle( unionIdxA + 1 + nIns );
			makeNewTriangles( unionIdxA + 1 + nIns );
			nIns += n - 1;
			
		} else {
			
			makeNewTriangles( unionIdxA + 1 );
			nIns += n - 1;
			calculateFrontAngle( unionIdxA );
			makeNewTriangles( unionIdxA );
			nIns += n - 1;
		}
		
		calculateFrontAngle( unionIdxB + nIns );
		calculateFrontAngle( unionIdxB + 1 + nIns );
		
		if ( front[ unionIdxB + nIns ].ang < front[ unionIdxB + 1 + nIns ].ang ) {
			
			makeNewTriangles( unionIdxB + nIns );
			nIns += n - 1;
			calculateFrontAngle( unionIdxB + 1 + nIns );
			makeNewTriangles( unionIdxB + 1 + nIns );
			
		} else {
			
			makeNewTriangles( unionIdxB + 1 + nIns );
			calculateFrontAngle( unionIdxB + nIns );
			makeNewTriangles( unionIdxB + nIns );
			
		}
		
	}	
	
	function checkDistancesToSplit( m ) { // for new active front points
	
		let mj, mjIdx, ddSplit;		
		let ddSplitMin = Infinity;
		split = false;
			
		for ( let i = 0; i < front.length ; i ++ ) {		
			
			if ( !front[ i ].bou ) { // not for boundary point
			
				for ( let j = 0; j < n; j ++ ) { // check n new points (insertFront)
				
					mj = m + j;
					
					// except new points themselves, neighbor and boundary points
					if ( Math.abs( i - mj ) > 3 && Math.abs( i - mj ) < front.length - 3 && !front[ mj ].bou ) {
											
						mjIdx = front[ mj ].idx * 3;
					
						// Hint: here (1) is exceptionally new point in the front!				
						x1 = g.positions[ mjIdx ]; 
						y1 = g.positions[ mjIdx + 1 ];
						z1 = g.positions[ mjIdx + 2 ];
	
						getPoint( i );
						
						ddSplit = squareLength ( x1 - xp, y1 - yp, z1 - zp );
						
						if ( ddSplit < dd && ddSplit < ddSplitMin ) {
	
							ddSplitMin = ddSplit;					
							iSplit = i;
							jSplit = mj;
							split = true; 
							
						}
						
					}
					
				}
				
			}
			
		}										
			
	}
		
	function splitFront( iSplit, jSplit ) {
		
		let k;
		
		front[ iSplit ].ang = 0;
		front[ jSplit ].ang = 0;
		
		if ( iSplit > jSplit )  { // swap
			
			k = jSplit;
			jSplit = iSplit;
			iSplit = k;
			
		} 
		
		splitIdx = iSplit;	// lower index
		
		partFront = [];
		
		// to duplicate
		let frontI = front[ iSplit ];		
		let frontJ = front[ jSplit ];
		
		partFront = front.splice( iSplit + 1, jSplit - iSplit - 1 );
		partFront.unshift( frontI );
		partFront.push( frontJ );
		
		fronts.push( partFront );
		
		partFrontBounds( );
		
		frontStock += 1; // new front created
		
	}
	
	function trianglesAtSplitPoints( ) {
		
		nIns = 0; // count inserted points
		
		let idx0 = splitIdx; // splitIdx is the lower index 
		let idx1 = splitIdx + 1;
		
		calculateFrontAngle( idx0 );
		calculateFrontAngle( idx1 );
		
		if ( front[ idx1 ].ang < front[ idx0 ].ang ){
		
			makeNewTriangles( idx1 );			
			nIns += n - 1;
			calculateFrontAngle( idx0 );
			makeNewTriangles( idx0 );
			
		} else {
			
			makeNewTriangles( idx0 );			
			nIns += n - 1;
			calculateFrontAngle( idx1 + nIns );
			makeNewTriangles( idx1 + nIns );
			
		}
		
	}

	function getMinimalAngleIndex( ) {
		
		let angle = Infinity;
		let m;
		
		for ( let i = 0; i < front.length; i ++ ) {
			
			if( front[ i ].ang < angle && !front[ i ].bou ) { // not for boundary point
				
				angle = front[ i ].ang ;
				m = i;
					
			}
			
		}

		return m;
		
	}
	
	function makeNewTriangles( m ) {
	
		let bdPoint; // border point
		
		insertFront = []; // new front points
		
		nT = Math.floor( 3 * front[ m ].ang / Math.PI ) + 1; // number of new triangles
		
		dAng = front[ m ].ang / nT;
		
		getPrevPoint( m );
		getPoint( m );
		getNextPoint( m );				
		getNormal( m );
		
		calculateTangentsPoint( );
		
		d1 = length( x1 - xp, y1 - yp, z1 - zp );
		d2 = length( x2 - xp, y2 - yp, z2 - zp );
		
		d12 = length( x2 - x1, y2 - y1, z2 - z1 );
		
		// correction of dAng, nT in extreme cases
		
		if ( dAng < 0.8 && nT > 1 ) {
			
			nT --;
			dAng = front[ m ].ang / nT;
			
		}
		
		if ( dAng > 0.8 && nT === 1 && d12 > 1.25 * d ) {
			
			nT = 2; 
			dAng = front[ m ].ang / nT;
			
		}
		
		if ( d1 * d1 < 0.2 * d * d ||  d2 * d2 < 0.2 * d * d  ) {
			
			nT = 1;
			
		}
		
		n = nT - 1;  // n number of new points
			
		if ( n === 0 ) { // one triangle
			
			g.indices[ indIdx     ] = front[ m ].idx;
			g.indices[ indIdx + 1 ] = front[ prevFront( m ) ].idx; 
			g.indices[ indIdx + 2 ] = front[ nextFront( m ) ].idx;
			
			indIdx += 3;
			
			/////////////// DEBUG triangles ///////////////////////
			//stp ++
			///////////////////////////////////////////////////////
			
			front[ prevFront( m ) ].ang = 0;		
			front[ nextFront( m ) ].ang = 0;			
			
			front.splice( m, 1 ); // delete point with index m from the front	
				
		} else { // more then one triangle
			
			// point p is center of circle in tangent plane
			
			xc = xp;
			yc = yp;
			zc = zp;
			
			phi = dAng; // start angle in tangential system
			
			for ( let i = 0 ; i < n; i ++ ) {
				
				calculateSurfacePointAndNormal( );
				
				// check bounds, correct coordinates if necessary
				
				bdPoint = false; // no boundary point
					
				if( xp > bd[ 0 ] || xp < bd[ 1 ] || yp > bd[ 2 ] || yp < bd[ 3 ] || zp > bd[ 4 ] || zp < bd[ 5 ] ) {
				
					if ( xp > bd[ 0 ] ) g.positions[ posIdx     ] = bd[ 0 ];
					if ( xp < bd[ 1 ] ) g.positions[ posIdx     ] = bd[ 1 ];				
					if ( yp > bd[ 2 ] )	g.positions[ posIdx + 1 ] = bd[ 2 ];										
					if ( yp < bd[ 3 ] ) g.positions[ posIdx + 1 ] = bd[ 3 ];				
					if ( zp > bd[ 4 ] ) g.positions[ posIdx + 2 ] = bd[ 4 ];
					if ( zp < bd[ 5 ] ) g.positions[ posIdx + 2 ] = bd[ 5 ];

					bdPoint = true; // boundary point
					
				}
				
				insertFront.push( { idx: posIdx / 3, ang: 0, bou: bdPoint } );
				
				posIdx += 3;
				
				phi += dAng;
				
			}
			 
			g.indices[ indIdx     ] = front[ m ].idx;
			g.indices[ indIdx + 1 ] = front[ prevFront( m ) ].idx 
			g.indices[ indIdx + 2 ] = insertFront[ 0 ].idx;
			
			indIdx += 3;
			
			/////////////// DEBUG triangles ///////////////////////
			//stp ++
			///////////////////////////////////////////////////////
			
			front[ prevFront( m ) ].ang = 0;
			
			for ( let i = 0; i < n - 1; i ++ ) {
				
				g.indices[ indIdx     ] = front[ m ].idx;
				g.indices[ indIdx + 1 ] = insertFront[ i ].idx;
				g.indices[ indIdx + 2 ] = insertFront[ i + 1 ].idx;
				
				indIdx += 3;
				
				/////////////// DEBUG triangles ///////////////////////
				//stp ++
				///////////////////////////////////////////////////////
				
			}
			
			g.indices[ indIdx     ] = front[ m ].idx;
			g.indices[ indIdx + 1 ] = insertFront[ n - 1 ].idx;
			g.indices[ indIdx + 2 ] = front[ nextFront( m ) ].idx;
			
			front[ nextFront( m ) ].ang = 0;

			indIdx += 3;
			
			/////////////// DEBUG triangles ///////////////////////
			//stp ++
			///////////////////////////////////////////////////////
			
			replaceFront( m, insertFront ); // replaces front[ m ] with new points
			
		}
			
	}

	function makeLastTriangle( ) {
		
		g.indices[ indIdx     ] = front[ 2 ].idx;
		g.indices[ indIdx + 1 ] = front[ 1 ].idx 
		g.indices[ indIdx + 2 ] = front[ 0 ].idx;
		
	}
	
	function chooseNextFront ( ) {
	
		let f
		
		if ( frontStock > 0 ) {
	
			for ( let i = 0; i < fronts.length; i ++ ) {
				
				if ( fronts[ i ].length > 0 ) {
					
					activeFrontNo = i;
					break;
					
				}
				
			}

			front = fronts[ activeFrontNo ];
			
		}
		
	}

	function calculateSurfacePointAndNormal( ) {	
		
		xp = xc + Math.cos( phi ) * d * xt1 + Math.sin( phi ) * d * xt2; 
		yp = yc + Math.cos( phi ) * d * yt1 + Math.sin( phi ) * d * yt2;
		zp = zc + Math.cos( phi ) * d * zt1 + Math.sin( phi ) * d * zt2;
		
		iterationNewton ( ); 
		
		g.positions[ posIdx     ] = xp;
		g.positions[ posIdx + 1 ] = yp;
		g.positions[ posIdx + 2 ] = zp;
		
		g.normals[ posIdx     ] = xn;
		g.normals[ posIdx + 1 ] = yn;
		g.normals[ posIdx + 2 ] = zn;	
		
	}
	
	function iterationNewton ( ) {
		
		let xp0, yp0, zp0;
		
		xp0 = xp;
		yp0 = yp;
		zp0 = zp;
		
		newtonStep( );
		
		while ( length( xp0 - xp, yp0 - yp, zp0 - zp  ) > e ) {
			
			xp0 = xp;
			yp0 = yp;
			zp0 = zp;
		
			newtonStep( );
			
		}

		len = length( xn, yn, zn ); // to normalize
		
		xn = xn / len;
		yn = yn / len;		
		zn = zn / len;
		
	}
	
	function newtonStep( ) {
		
		let cc, t;
		
		xn = dx( xp, yp, zp );
		yn = dy( xp, yp, zp );
		zn = dz( xp, yp, zp );
		
		cc = xn * xn + yn * yn + zn * zn;	
		
		if ( cc > e * e ) {
			
			t = -isf( xp, yp, zp ) / cc;
			
		} else {
			
			t = 0;
			console.log( 'WARNING tri (surface_point...): newton')			
			
		}
	
		xp = xp + t * xn;
		yp = yp + t * yn;
		zp = zp + t * zn;
		
	}

	function atan2PI( x, y ) {
		
		let phi = Math.atan2( y, x );
		
		if ( phi < 0 ) phi = phi + Math.PI * 2;

		return phi;
			
	}
	
	function coordTangentialSystem( ) {
		
		let det = determinant( xt1, yt1, zt1, xt2, yt2, zt2, xn, yn, zn );
		
		xs1 = determinant( x1 - xp, y1 - yp, z1 - zp, xt2, yt2, zt2, xn, yn, zn ) / det;
		ys1 = determinant( xt1, yt1, zt1, x1 - xp, y1 - yp, z1 - zp, xn, yn, zn ) / det;
		//zs1 = determinant( xt1, yt1, zt1, xt2, yt2, zt2, x1 - xp, y1 - yp, z1 - zp ) / det; // not needed
		
		xs2 = determinant( x2 - xp, y2 - yp, z2 - zp, xt2, yt2, zt2, xn, yn, zn ) / det;
		ys2 = determinant( xt1, yt1, zt1, x2 - xp, y2 - yp, z2 - zp, xn, yn, zn ) / det;
		//zs2 = determinant( xt1, yt1, zt1, xt2, yt2, zt2, x2 - xp, y2 - yp, z2 - zp ) / det; // not needed
		
	}
	
	function calculateFrontAngle( i ) {
	
		let ang1, ang2;
		
		getPrevPoint( i ); // (1)
		getPoint( i );
		getNextPoint( i ); // (2)
		
		coordTangentialSystem( );
	
		ang1 = atan2PI( xs1, ys1 );
		ang2 = atan2PI( xs2, ys2 );
		
		if ( ang2 < ang1 )  ang2 += Math.PI * 2;
		
        front[ i ].ang  = ang2 - ang1;
		
		if ( front[ i ].ang < 1.5 ) smallAngles.push( i );
		
	}	
	
	function partFrontBounds( ) {
		
		let x, y, z, idx, xmin, ymin, zmin, xmax, ymax, zmax;
		
		partBounds = [];
		
		xmin = ymin = zmin = Infinity;
		xmax = ymax = zmax = -Infinity;
		
		for( let i = 0; i < partFront.length; i ++ ) {
			
			idx = partFront[ i ].idx * 3;
			
			x = g.positions[ idx ]; 
			y = g.positions[ idx + 1 ];
			z = g.positions[ idx + 2 ];
			
			xmin = x < xmin ? x : xmin; 
			ymin = y < ymin ? y : ymin;
			zmin = z < zmin ? z : zmin;
			
			xmax = x > xmax ? x : xmax;
			ymax = y > ymax ? y : ymax;
			zmax = z > zmax ? z : zmax;
			
		}
		
		partBounds.push( xmin, ymin, zmin, xmax, ymax, zmax );
		
		boundings.push( partBounds );
		
	}
	
	function replaceFront( m, fNew ) {
		
		let rear = front.splice( m, front.length - m );
		
		for ( let i = 0; i < fNew.length; i ++ ) {
			
			front.push( fNew[ i ] ); // new front points
			
		}
		
		for ( let i = 1; i < rear.length; i ++ ) { // i = 1: without old front point m 
			
			front.push( rear[ i ] );
			
		}
		
	}
	
	function getNormal( i ){
	
		frontPosIdx = front[ i ].idx * 3;
		
		xn = g.normals[ frontPosIdx ]; 
		yn = g.normals[ frontPosIdx + 1 ];
		zn = g.normals[ frontPosIdx + 2 ];		
		
	}
	
	function calculateTangentsPoint( ) {
		
		// cross

		xt2 = yn * ( z1 - zp ) - zn * ( y1 - yp );
		yt2 = zn * ( x1 - xp ) - xn * ( z1 - zp );
		zt2 = xn * ( y1 - yp ) - yn * ( x1 - xp );
	
		len = length( xt2, yt2, zt2 ); // to normalize
		
		xt2 = xt2 / len;
		yt2 = yt2 / len;
		zt2 = zt2 / len; 	
		
		// cross
		xt1 = yt2 * zn - zt2 * yn;
		yt1 = zt2 * xn - xt2 * zn;
		zt1 = xt2 * yn - yt2 * xn;
		
	}
	 	
	function getPrevPoint( i ) {
		
		frontPosIdx = front[ prevFront( i ) ].idx * 3;
		
		x1 = g.positions[ frontPosIdx ]; 
		y1 = g.positions[ frontPosIdx + 1 ];
		z1 = g.positions[ frontPosIdx + 2 ];
		
	}
	
	function getPoint( i ) {
		
		frontPosIdx = front[ i ].idx * 3;
		
		xp = g.positions[ frontPosIdx ]; 
		yp = g.positions[ frontPosIdx + 1 ];
		zp = g.positions[ frontPosIdx + 2 ];
		
	}
	
	function getNextPoint( i ) {
		
		frontPosIdx = front[ nextFront( i ) ].idx * 3;
		
		x2 = g.positions[ frontPosIdx ];
		y2 = g.positions[ frontPosIdx + 1 ];
		z2 = g.positions[ frontPosIdx + 2 ];
		
	}
	
}

</script>

</html>